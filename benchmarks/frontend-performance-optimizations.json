{
  "_meta": {
    "title": "前端性能优化大全 (Comprehensive Frontend Performance Optimizations)",
    "description": "一份详尽的前端性能优化指南，涵盖从网络、渲染、JavaScript执行到微观代码层面的各种技巧。",
    "version": "1.0.0",
    "createdAt": "2025-12-27T08:00:00.000Z"
  },
  "categories": {
    "network": {
      "name": "网络优化 (Network)",
      "description": "减少网络请求延迟和传输大小相关的优化。",
      "optimizations": [
        {
          "name": "HTTP/2 或 HTTP/3",
          "description": "利用新一代HTTP协议的多路复用、头部压缩等特性，减少网络延迟。",
          "performance_gain_level": "巨大 (Huge)",
          "use_case": "所有现代Web应用，特别是多资源站点。",
          "pros": ["显著减少多请求延迟", "单个TCP连接，减少握手开销"],
          "cons": ["需要服务器和CDN支持", "在丢包率高的网络环境下可能表现不佳"]
        },
        {
          "name": "资源压缩 (Gzip, Brotli)",
          "description": "在服务器端对文本类资源（HTML, CSS, JS）进行压缩，减少传输体积。",
          "performance_gain_level": "巨大 (Huge)",
          "use_case": "所有Web应用。",
          "pros": ["Brotli压缩率比Gzip更高", "显著减少下载时间"],
          "cons": ["服务器需要消耗CPU进行压缩", "Brotli需要HTTPS"]
        },
        {
          "name": "代码分割与懒加载 (Code Splitting & Lazy Loading)",
          "description": "将代码库分割成小块，仅在需要时（如路由切换、组件即将进入视口）通过动态 import() 加载。",
          "performance_gain_level": "巨大 (Huge)",
          "use_case": "大型单页应用（SPA）。",
          "pros": ["极大减少初始加载体积和解析时间", "提升首页渲染速度和FCP/LCP"],
          "cons": ["增加构建配置复杂度", "可能导致后续交互的短暂延迟"]
        },
        {
          "name": "使用CDN (Content Delivery Network)",
          "description": "将静态资源部署到全球分布的CDN节点，用户从最近的节点加载资源，减少延迟。",
          "performance_gain_level": "显著 (Significant)",
          "use_case": "面向全球用户的应用。",
          "pros": ["极大降低地理位置带来的延迟", "高可用性和负载均衡"],
          "cons": ["产生额外费用", "缓存刷新可能存在延迟"]
        }
      ]
    },
    "rendering": {
      "name": "渲染优化 (Rendering)",
      "description": "提升浏览器渲染性能，减少重绘和重排。",
      "optimizations": [
        {
          "name": "避免强制同步布局 (Layout Thrashing)",
          "description": "在JavaScript中，避免连续的“写”操作（改变样式）和“读”操作（获取布局信息如 offsetHeight）交错进行。应先批量读取，再批量写入。",
          "performance_gain_level": "显著 (Significant)",
          "use_case": "涉及大量DOM操作和动画的场景。",
          "pros": ["避免不必要的重排，极大提升脚本执行效率"],
          "cons": ["需要开发者有意识地组织代码结构"]
        },
        {
          "name": "使用 CSS Transform 和 Opacity 实现动画",
          "description": "优先使用只会触发合成（Composite）的CSS属性（transform, opacity）来实现动画，避免触发布局（Layout）和绘制（Paint）。",
          "performance_gain_level": "显著 (Significant)",
          "use_case": "所有UI动画。",
          "pros": ["动画在单独的合成器线程运行，非常流畅", "可利用GPU加速"],
          "cons": ["能实现的动画效果有限"]
        },
        {
          "name": "虚拟列表 (Virtual Scrolling)",
          "description": "对于长列表，只渲染视口内可见的少数列表项，极大减少DOM节点数量。",
          "performance_gain_level": "巨大 (Huge)",
          "use_case": "需要展示成千上万条数据的列表或表格。",
          "pros": ["数量级地减少DOM节点，避免页面卡顿"],
          "cons": ["实现复杂，滚动条行为可能不自然", "需要精确计算项目高度"]
        }
      ]
    },
    "javascript": {
      "name": "JavaScript 执行优化",
      "description": "提升JavaScript代码的执行效率。",
      "optimizations": [
        {
          "name": "事件委托 (Event Delegation)",
          "description": "在父元素上监听事件，而不是为每个子元素都绑定事件监听器，利用事件冒泡来处理。",
          "performance_gain_level": "中等 (Medium)",
          "use_case": "大量列表项或表格单元格需要响应相同事件的场景。",
          "pros": ["减少内存占用", "动态添加的子元素也能响应事件"],
          "cons": ["不适用于所有事件（如 focus, blur）", "代码逻辑可能稍微复杂"]
        },
        {
          "name": "Web Workers",
          "description": "将CPU密集型计算（如大量数据处理、加密）放到一个单独的后台线程中执行，避免阻塞主线程（UI线程）。",
          "performance_gain_level": "巨大 (Huge)",
          "use_case": "需要进行大量计算的前端应用，如在线编辑器、数据可视化。",
          "pros": ["避免UI卡顿，提升应用响应性"],
          "cons": ["Worker与主线程通信有开销", "Worker中无法访问DOM"]
        }
      ]
    },
    "resources": {
      "name": "资源优化 (Resources)",
      "description": "针对图片、字体等资源的优化。",
      "optimizations": [
        {
          "name": "图片懒加载 (Image Lazy Loading)",
          "description": "仅当图片即将进入视口时才开始加载。现代浏览器已原生支持 `loading=\"lazy\"` 属性。",
          "performance_gain_level": "显著 (Significant)",
          "use_case": "任何包含多张非首屏图片的页面。",
          "pros": ["减少首屏加载的资源数量，提升LCP"],
          "cons": ["可能导致快速滚动时图片加载延迟"]
        },
        {
          "name": "使用现代图片格式 (WebP, AVIF)",
          "description": "使用WebP或AVIF格式代替JPEG/PNG，它们在同等质量下体积更小。",
          "performance_gain_level": "显著 (Significant)",
          "use_case": "所有使用图片的场景。",
          "pros": ["极大减少图片文件大小"],
          "cons": ["需要处理浏览器兼容性（使用 <picture> 标签）"]
        }
      ]
    },
    "micro_optimizations": {
      "name": "微优化 (Micro-optimizations)",
      "description": "在性能热路径中可能产生影响的微小代码层面的优化。",
      "optimizations": [
        {
          "name": "缓存数组长度 (Cache Array Length)",
          "description": "在 for 循环的条件判断中，使用一个变量缓存数组的长度，而不是每次迭代都访问 `.length` 属性。",
          "performance_gain_level": "微小 (Micro)",
          "use_case": "需要遍历大数组的性能热路径。",
          "pros": ["避免重复的属性访问，在某些JS引擎中能带来微小提升"],
          "cons": ["代码稍微冗长", "现代JS引擎的优化可能使其效果不明显"]
        },
        {
          "name": "倒序循环 (Reverse Loop)",
          "description": "当迭代顺序不重要时，使用倒序循环 `for (let i = arr.length; i--;)`。它将长度读取和条件判断合并为一步。",
          "performance_gain_level": "微小 (Micro)",
          "use_case": "需要遍历大数组且顺序无关的性能热路径。",
          "pros": ["代码更简洁", "理论上比缓存长度的正序循环更快一点"],
          "cons": ["改变了迭代顺序，不适用于所有场景"]
        },
        {
          "name": "避免使用 `forEach` (在热路径中)",
          "description": "在需要极致性能的热路径中，使用原生的 `for` 或 `for...of` 循环代替 `forEach`，因为 `forEach` 涉及额外的函数调用开销。",
          "performance_gain_level": "微小 (Micro)",
          "use_case": "每秒执行成千上万次的循环，例如游戏循环、高频数据处理。",
          "pros": ["减少函数调用栈，执行更快"],
          "cons": ["代码可读性可能稍差", "在绝大多数非热路径场景下，性能差异可忽略不计"]
        }
      ]
    }
  }
}

