{
  "config": {
    "version": "3.2.8",
    "description": "LD框架AI代码生成指南 - 智能依赖分析版",
    "lastUpdated": "2025-12-25T18:30:00.000Z",
    "aiInstruction": "本文件包含LD框架代码生成的所有规则。请严格遵循以下工作流程：1.读取配置→2.分析现有文件→3.设计代码→4.生成代码→5.更新状态→6.验证质量。特别注意：每次生成代码前必须分析现有模块导出，识别依赖关系，然后生成代码，最后更新测试文件并运行测试。"
  },
  "project": {
    "name": "ld",
    "description": "LD(L:light D:author's lastName)框架是一个追求极致性能的前端框架，旨在提供比现有方案更快的响应式系统和渲染性能。框架完全兼容Vue3语法和生态系统和React(Hooks)语法和生态系统，同时实现了零虚拟DOM的细粒度更新系统。",
    "version": "0.1.0",
    "slogan": "极致性能前端框架",
    "goal": "light!fast!performance!typescript!vue!react!",
    "reactCompatibility": "React(Hooks)语法/生态完全兼容",
    "vueCompatibility": "Vue3语法/生态完全兼容",
    "performanceTargets": {
      "signalCreate": "<0.01ms",
      "signalGet": "<0.001ms",
      "signalSet": "<0.005ms",
      "bundleSize": "<10KB gzipped",
      "componentMount": "<0.1ms",
      "componentUpdate": "<0.05ms"
    }
  },
  "current": {
    "module": {
      "id": "runtime-dom",
      "file": null,
      "status": "pending",
      "progress": "runtime-core模块已完成，准备开始runtime-dom模块。",
      "dependencyAnalysisNeeded": true
    },
    "nextBatch": {
      "files": [
        "component/index.ts"
      ],
      "completionTrigger": "reactivity模块完成后自动触发"
    }
  },
  "modules": {
    "generationOrder": [
      "reactivity",
      "runtime-core",
      "runtime-dom",
      "runtime-jsx",
      "react",
      "vue",
      "compiler-core",
      "compiler-sfc",
      "router",
      "ld",
      "vite-plugin",
      "cli",
      "devtools",
      "babel-plugin-ld"
    ],
    "detailed": {
      "reactivity": {
        "status": "completed",
        "mission": "实现零虚拟DOM的细粒度更新系统，性能超越所有现有方案",
        "dependencies": [],
        "files": {}
      },
      "runtime-core": {
        "status": "completed",
        "mission": "定义一个通用的组件中间表示（IR），并将此IR编译成一个高度优化的JavaScript文件。此输出文件将包含直接的DOM操作、事件处理和状态逻辑，形成一个独立的‘DOM组件’。",
        "dependencies": [
          "reactivity"
        ],
        "files": {}
      },
      "runtime-dom": {
        "status": "active",
        "mission": "提供浏览器环境的DOM操作API，将平台无关的渲染指令转换为实际的DOM操作。",
        "dependencies": [
          "@ld/runtime-core"
        ],
        "files": {}
      },
      "runtime-jsx": {
        "status": "pending",
        "mission": "提供TSX/JSX的运行时支持，将JSX调用直接转换为原生DOM操作，绕过Virtual DOM。",
        "dependencies": [
          "@ld/runtime-core"
        ],
        "files": {}
      },
      "react": {
        "status": "pending",
        "mission": "提供与React Hooks API完全兼容的适配层，底层实现基于@ld/reactivity。",
        "dependencies": [
          "@ld/reactivity"
        ],
        "files": {}
      },
      "vue": {
        "status": "pending",
        "mission": "提供与Vue Composition API完全兼容的适配层，底层实现基于@ld/reactivity。",
        "dependencies": ["@ld/reactivity"],
        "files": {}
      },
      "ld": {
        "status": "pending",
        "mission": "作为框架的统一入口（Facade），智能地重新导出@ld/reactivity、@ld/vue、@ld/react等核心模块的API。",
        "dependencies": ["@ld/reactivity", "@ld/vue", "@ld/react"],
        "files": {}
      },
      "babel-plugin-ld": {
        "status": "pending",
        "mission": "创建一个Babel插件，用于在编译时将TSX/JSX转换为对@ld/runtime-jsx的调用。",
        "dependencies": [],
        "files": {}
      }
    },
    "rule": "只对current.module.id指定的模块生成详细的files配置。切换到新模块时，才为其填充详细配置。"
  },
  "principles": {
    "nonNegotiable": [
      "zeroBugs",
      "extremePerformance",
      "fullVue3Compatibility",
      "typeSafety",
      "memorySafety",
      "minimalBundleSize"
    ],
    "lazyLoading": {
      "components": "所有组件和路由都必须支持基于 import() 的代码分割，实现按需加载。",
      "styles": "编译产物必须能生成独立的CSS文件。运行时必须在组件首次挂载时，通过 <link> 或 <style> 标签动态注入其作用域（scoped）样式。",
      "fetchStrategy": "运行时必须允许用户自定义资源加载逻辑（fetch/import），以支持CDN、缓存等高级策略。"
    },
    "architecture": {
      "noVirtualDOM": true,
      "signalBased": true,
      "treeShakable": true,
      "esModules": true,
      "centralizedState": "框架范围内的共享状态（如响应式代理缓存、调度器相关的状态，包括调度队列、刷新标志 `isFlushing` 和 `isFlushPending`、以及批处理标志 `isBatching`）必须集中在专用的 `store.ts` 模块的 `globalState` 对象中管理，禁止在功能模块中使用文件作用域的局部变量来存储全局状态。",
      "globalVsInstanceStore": "必须严格区分全局状态和实例状态。全局状态（`globalState`）仅用于管理整个框架共享的调度器（如队列、刷新标志）和全局缓存（如响应式代理缓存）。所有与特定上下文（如组件实例）相关的状态，都必须通过 `createInstanceStore` 工厂函数创建和管理，以确保状态隔离和框架的可扩展性。",
      "jsxTransformation": "TSX/JSX 必须通过编译时插件（如@ld/babel-plugin-ld）直接转换为对@ld/runtime-jsx 的原生DOM操作调用，严禁引入或依赖任何Virtual DOM实现。",
      "hooksCompatibilityLayer": "@ld/react 模块必须作为一个纯粹的兼容层存在。所有Hooks的实现都必须基于@ld/reactivity 的核心原语（createSignal, createEffect等），以保证框架响应式系统的一致性和性能优势。",
      "adapterSeparation": "框架的API适配层必须分离到独立的包中（如@ld/vue, @ld/react），以确保用户可以按需加载，实现最小打包体积。",
      "unifiedEntryPoint": "主包 'ld' 必须作为一个统一入口（Facade）存在，它负责重新导出核心和适配器模块的常用API，为用户提供'开箱即用'的便利性，同时允许从特定子包直接导入。",
      "compilationStrategy": "框架必须采用混合编译策略：利用官方或成熟的解析器（如@vue/compiler-sfc, Babel）将.vue和.tsx文件解析为AST，但必须使用自研的代码生成器将AST直接编译为不依赖Virtual DOM的、基于Signal的细粒度原生DOM操作。",
      "sfcCompilation": {
        "strategy": "混合编译方案",
        "description": "采用混合编译策略处理.vue单文件组件，平衡性能、维护成本和生态兼容性",
        "workflow": {
          "step1_parsing": {
            "tool": "@vue/compiler-sfc",
            "purpose": "解析.vue文件，提取template、script、style三个部分",
            "output": "Vue SFC AST（包含template AST、script AST、style信息）",
            "reason": "利用成熟的Vue官方解析器，确保100%兼容Vue3 SFC语法，处理所有边缘情况"
          },
          "step2_templateTransformation": {
            "tool": "自研转换器（@ld/compiler-core）",
            "purpose": "将Vue template AST转换为LD框架的中间表示（IR）",
            "output": "LD IR（包含DOM操作指令、Signal绑定、事件处理等）",
            "optimizations": [
              "静态提升：将静态节点提取到组件外部",
              "常量折叠：编译时计算常量表达式",
              "Signal识别：识别响应式绑定，优化为直接Signal操作",
              "事件优化：将事件处理函数内联或优化绑定"
            ]
          },
          "step3_codeGeneration": {
            "tool": "自研代码生成器（@ld/compiler-core）",
            "purpose": "将LD IR直接编译为原生JavaScript代码，包含直接的DOM操作",
            "output": "优化的JavaScript代码（无Virtual DOM，直接DOM操作）",
            "features": [
              "直接DOM操作：createElement, appendChild, setAttribute等",
              "Signal集成：自动生成createSignal、createEffect调用",
              "事件绑定：直接addEventListener，无需中间层",
              "性能优化：最小化运行时开销，最大化JIT友好性"
            ]
          },
          "step4_scriptIntegration": {
            "tool": "自研集成器",
            "purpose": "将编译后的template代码与script setup代码合并",
            "output": "完整的组件JavaScript文件",
            "features": [
              "自动导入：自动添加必要的@ld/reactivity导入",
              "类型安全：保持TypeScript类型信息",
              "Tree Shaking：确保未使用的代码可被正确移除"
            ]
          }
        },
        "advantages": [
          "性能：自研代码生成器可针对LD框架做极致优化",
          "兼容性：使用@vue/compiler-sfc确保100% Vue3语法兼容",
          "体积：只引入必要的解析器，代码生成器轻量级",
          "维护性：解析器由Vue团队维护，我们只需维护代码生成器",
          "可扩展性：可在代码生成阶段自由添加优化策略"
        ],
        "implementation": {
          "compilerSfcModule": "@ld/compiler-sfc",
          "compilerCoreModule": "@ld/compiler-core",
          "dependencies": {
            "parsing": "@vue/compiler-sfc (仅用于解析，不包含代码生成)",
            "transformation": "自研（@ld/compiler-core/src/transform）",
            "codegen": "自研（@ld/compiler-core/src/codegen）"
          }
        }
      },
      "jsxCompilation": {
        "strategy": "混合编译方案",
        "description": "采用混合编译策略处理.tsx/.jsx文件",
        "workflow": {
          "step1_parsing": {
            "tool": "@babel/parser",
            "purpose": "解析TSX/JSX语法，生成Babel AST",
            "output": "Babel AST",
            "reason": "利用成熟的Babel解析器，支持所有JS/TS/JSX语法特性"
          },
          "step2_transformation": {
            "tool": "@ld/babel-plugin-ld",
            "purpose": "将JSX语法转换为对@ld/runtime-jsx的h函数调用",
            "output": "包含h函数调用的AST",
            "features": [
              "JSX元素 → h(tag, props, children)",
              "JSX Fragment → h(Fragment, null, children)",
              "Signal识别：自动识别响应式值，优化绑定"
            ]
          },
          "step3_codeGeneration": {
            "tool": "Babel代码生成器 + 自研优化",
            "purpose": "将AST转换为JavaScript代码，并进行运行时优化",
            "output": "优化的JavaScript代码",
            "optimizations": [
              "静态提升",
              "常量折叠",
              "Signal优化"
            ]
          }
        }
      }
    },
    "qualityGates": {
      "correctness": "函数必须注释Pre/Post-conditions，错误必须是特定类型，资源必须自动清理",
      "performance": "JIT友好，CPU缓存友好，渲染优先，零GC开销",
      "dependencies": "模块依赖必须清晰、单向、无循环，使用import type解耦"
    },
    "optimizations": [
      "aotCompilation",
      "staticHoisting",
      "constantFolding",
      "memoryPooling",
      "cachingEverything",
      "lazyEvaluation"
    ]
  },
  "workflow": {
    "preGeneration": {
      "checks": [
        "分析现有导出",
        "识别依赖关系",
        "设计算法",
        "内存策略",
        "类型规划",
        "测试规划"
      ],
      "rules": [
        "必须先读取index.ts和module.ts",
        "分析已存在的模块导出",
        "确保无TypeScript错误",
        "无未使用变量",
        "标注复杂度",
        "处理所有错误"
      ],
      "criticalFiles": {
        "index.ts": "packages/[module]/src/index.ts",
        "module.ts": "packages/module.ts",
        "purpose": "分析现有模块导出，识别依赖关系"
      }
    },
    "generation": {
      "batchLogic": "读current.module.id→分析现有导出→智能批量→优先底层依赖→强依赖一起生成",
      "dependencyAnalysisRequired": true,
      "priority": [
        "signal.ts",
        "effect.ts",
        "computed.ts",
        "reactive.ts",
        "batch.ts",
        "scheduler.ts"
      ],
      "importRules": {
        "internal": "从当前模块的index.ts导入",
        "external": "从其他模块的导出导入",
        "typeOnly": "类型导入必须使用import type",
        "checkExisting": "导入前检查目标模块是否已导出所需API"
      }
    },
    "postGeneration": {
      "updates": [
        "更新模块的index.ts",
        "更新框架的module.ts",
        "更新当前状态",
        "更新vitest.workspace.ts以包含新模块的测试"
      ],
      "validations": [
        "逻辑正确",
        "性能达标",
        "内存安全",
        "类型兼容",
        "运行单元测试"
      ],
      "qualityAssurance": [
        "生成前: 分析现有依赖，模拟运行和边界分析",
        "生成中: 实时验证算法和性能",
        "生成后: 虚拟类型检查和内存安全检查"
      ],
      "performanceTuning": {
        "rule": "在所有单元测试通过后，必须对当前模块进行性能评测和优化。",
        "steps": [
          "1. 为新功能创建或更新 .bench.ts 性能测试文件。",
          "2. 运行 `pnpm bench` 获取真实性能数据。",
          "3. 分析结果，定位性能瓶颈。",
          "4. 实施代码优化，直至性能超越基准目标（如 SolidJS）。",
          "5. 重新运行评测以验证优化效果。"
        ],
        "qualityGate": "性能必须达到或超过 `project.performanceTargets` 中定义的目标，并与业界顶级标准保持竞争力。"
      }
    },
    "moduleCompletion": {
      "rule": "在每个主要模块的所有文件生成和测试通过后，必须执行以下两个步骤：",
      "steps": [
        {
          "action": "generateReadme",
          "description": "为模块生成一个详细的 README.md 文件，内容包括模块的核心功能、所有导出API的使用方法和示例代码。",
          "path": "packages/[module]/readme.md"
        },
        {
          "action": "generateRollupConfig",
          "description": "为模块生成一个 `rollup.config.js` 文件，用于独立打包该模块。",
          "path": "packages/[module]/rollup.config.js"
        },
        {
          "action": "bundleModule",
          "description": "根据模块的 rollup.config.js 文件，使用 Rollup 对该模块进行打包。",
          "command": "pnpm --filter @ld/[module] build"
        }
      ]
    }
  },
  "testing": {
    "strategy": {
      "name": "智能选择性测试 (Intelligent Selective Testing)",
      "description": "测试运行器 (`scripts/test.mts`, `scripts/test-ai.mts`) 会自动读取本指导文件，并只对 `modules.detailed` 中状态为 'completed' 或 'active' 的模块运行测试。这避免了对未开发模块的无效测试，保持了测试输出的清晰。",
      "implementation": "该逻辑由 `scripts/utils/get-active-packages.mts` 实现。"
    },
    "rule": "在生成或修改任何.ts文件后，必须立即更新并只运行其对应的测试文件（例如，修改 a.ts 后只运行 a.test.ts）。这可以确保测试的精确性和效率。先添加可能导致测试不通过的用例，运行测试，若有失败则修复问题后再次运行测试，直到通过为止。",

    "qualityGate": "需包含失败用例修复的验证，所有测试通过才能继续下一步",
    "command": {
      "singleFile": "pnpm test:ai -- packages/[module]/test/[filename].test.ts",
      "currentModule": "pnpm test:ai -- packages/[module]/test",
      "allModules": "pnpm test:ai"
    },
    "resultAnalysis": "pnpm test:ai:results 或 node scripts/ai-test-helper.mts analyze",
    "continuityCheck": "node scripts/ai-test-helper.mts check",
    "fileGeneration": {
      "path": "packages/[module]/test/[filename].test.ts",
      "structure": "import { describe, it, expect } from 'vitest'; describe('模块名', () => { it('测试用例描述', () => { expect(...).toBe(...) }) })",
      "coverage": "必须覆盖: 1. 正常用例 2. 边界用例 3. 错误用例 4. 补充不通过后修复的用例"
    }
  },
  "templates": {
    "jsdoc": {
      "function": {
        "required": [
          "@description",
          "@param",
          "@returns",
          "@example",
          "@performance",
          "@note",
          "@since"
        ],
        "example": "/**\n * 创建响应式信号\n * @description 创建一个可追踪变化的响应式值容器...\n * @param initial - 初始值\n * @returns [getter, setter]元组\n * @example\n * const [count, setCount] = createSignal(0);\n * @performance 创建<0.01ms, 读取<0.001ms\n * @since v0.1.0\n */"
      },
      "type": {
        "required": [
          "@description",
          "@example",
          "@since"
        ],
        "example": "/**\n * 信号类型定义\n * @description Signal的类型定义...\n * @template T - 信号值类型\n * @since v0.1.0\n */"
      }
    },
    "exports": {
      "indexTs": {
        "purpose": "模块API出口，所有外部导入必须通过此文件",
        "rule": "按来源文件分组导出，不要混合不同文件的导出",
        "example": "// ===== signal.ts =====\nexport { createSignal } from './signal';\nexport type { Signal } from './signal';"
      },
      "moduleTs": {
        "purpose": "框架主入口，聚合所有模块导出",
        "rule": "每个导出单独列出，附带完整JSDoc，禁止export *",
        "analysisPurpose": "分析时读取此文件了解已存在的模块导出"
      }
    },
    "codeStyle": {
      "imports": {
        "external": "import xxx from '@ld/模块名'",
        "internal": "import xxx from './index.ts'",
        "typeOnly": "import type { TypeName } from '@ld/模块名'",
        "analysisRule": "导入前必须检查目标模块的index.ts是否已导出所需API"
      },
      "exports": {
        "value": "export { functionName } from '@ld/module';",
        "type": "export type { TypeName } from '@ld/module';",
        "aliasing": "仅命名冲突时: export { originalName as aliasName } from '@ld/module';"
      },
      "naming": {
        "functions": "camelCase: createSignal, createEffect",
        "types": "PascalCase: Signal, EffectOptions",
        "constants": "UPPER_SNAKE_CASE"
      }
    }
  },
  "quality": {
    "checklist": {
      "syntax": "无TS错误，类型安全，导入导出正确",
      "dependencyAnalysis": "正确分析现有模块导出，依赖关系正确",
      "performance": "标注复杂度，内存管理，GC友好",
      "readability": "命名规范，注释完整，结构清晰",
      "maintainability": "模块化，可测试，可扩展",
      "noUnusedVariables": "禁止声明未使用的变量"
    },
    "tooling": {
      "linter": "ESLint: @typescript-eslint/recommended, 禁止any",
      "formatter": "Prettier: singleQuote, tabWidth 2, printWidth 100",
      "test": "Vitest: 每个模块必须有单元测试",
      "bundler": "Rollup: 输入src/index.ts，输出esm/cjs",
      "benchmark": "tinybench: 用于性能评测"
    }
  },
  "aiRules": {
    "mandatory": [
      "必须读取本配置后才能开始生成",
      "必须按照workflow步骤执行，特别是preGeneration的分析步骤",
      "必须分析现有index.ts和module.ts文件，识别已存在的导出",
      "必须验证每一步结果",
      "必须更新current状态",
      "必须生成测试并运行测试通过后才能继续下一步",
      "所有跨模块共享的内部状态必须在专用的 `store.ts` 模块中进行管理。",
      "所有代码注释、JSDoc和说明性文本必须使用中文。",
      "必须明确区分全局状态和实例状态，并使用 `store.ts` 进行管理。",
      "为一个新模块首次成功生成测试文件后，必须立即更新 vitest.workspace.ts 文件，将该新模块的配置添加到列表中。",
      "为一个新模块首次成功生成测试文件后，必须立即更新 vitest.workspace.ts 文件，将该新模块的配置添加到列表中。",
      "在处理.tsx文件时，必须假设@ld/babel-plugin-ld已生效，并将JSX语法视为对@ld/runtime-jsx中h函数的调用。",
      "在@ld/react模块中实现任何React Hook时，必须使用@ld/reactivity的核心API（如createSignal, createEffect）作为其底层实现。",
      "【代码质量】禁止生成任何未使用的变量。",
      "【性能】所有核心算法必须以最低的时间复杂度和空间复杂度实现。",
      "【微优化】在性能敏感的热路径循环中，必须缓存数组长度（`for (let i = 0, len = arr.length; i < len; i++)`）或使用倒序循环（`for (let i = arr.length; i--;)`），严禁在循环条件中直接使用`.length`。"
    ],
    "prohibited": [
      "禁止跳过验证步骤，特别是依赖分析步骤",
      "禁止修改配置结构",
      "禁止创建不符合principles的代码",
      "禁止在不读取配置和现有文件的情况下生成代码",
      "禁止在测试未通过时生成下一个文件"
    ],
    "stateSync": "每次操作后必须立即更新current状态，状态是唯一真相源"
  },
  "fileSystem": {
    "criticalFiles": {
      "module.ts": {
        "path": "packages/module.ts",
        "purpose": "框架主入口，所有用户从此导入",
        "analysisImportance": "必须读取此文件以了解已存在的模块导出",
        "updateRule": "任何模块的index.ts更新后必须立即更新"
      },
      "index.ts": {
        "path": "packages/[module]/src/index.ts",
        "purpose": "模块API出口",
        "analysisImportance": "必须读取此文件以了解模块内部导出",
        "updateRule": "生成或修改模块内任何.ts文件后必须立即更新"
      },
      "testFiles": {
        "path": "packages/[module]/test/[filename].test.ts",
        "purpose": "单元测试文件",
        "updateRule": "生成或修改任何.ts文件后必须立即更新对应的测试文件并运行测试",
        "critical": true
      }
    },
    "analysisWorkflow": {
      "beforeGenerate": [
        "检查packages/module.ts是否存在并读取内容",
        "检查目标模块的index.ts是否存在并读取内容",
        "分析已导出的API和类型",
        "识别模块间的依赖关系",
        "确保导入的依赖已存在"
      ],
      "afterGenerate": [
        "更新目标模块的index.ts",
        "更新packages/module.ts",
        "生成/更新测试文件",
        "运行测试验证"
      ]
    },
    "checkBeforeGenerate": "生成代码前必须检查并分析module.ts和index.ts的内容，了解现有导出和依赖关系"
  },
  "examples": {
    "scenario": "生成reactivity模块的effect.ts",
    "steps": [
      "1. 读取current: 确定当前模块是reactivity，要生成effect.ts",
      "2. 分析现有文件: 读取packages/module.ts和packages/reactivity/src/index.ts（如果存在）",
      "3. 识别依赖: 分析effect.ts依赖的signal.ts是否已存在并导出",
      "4. 读取modules.detailed.reactivity: 获取effect.ts的详细配置",
      "5. 读取principles: 确保设计符合核心原则",
      "6. 设计导入: 根据现有导出设计effect.ts的导入语句",
      "7. 生成effect.ts代码: 遵循workflow规则",
      "8. 更新index.ts: 导出effect.ts的API",
      "9. 更新module.ts: 添加来自reactivity模块的导出",
      "10. 生成/更新测试文件: 创建packages/reactivity/test/effect.test.ts",
      "11. 运行测试: 执行vitest运行测试，确保所有测试通过",
      "12. 更新current: 记录完成状态，准备下一个文件"
    ]
  },
  "dependencyAnalysis": {
    "required": true,
    "filesToAnalyze": [
      "packages/module.ts",
      "packages/reactivity/src/index.ts",
      "packages/runtime-core/src/index.ts",
      "packages/runtime-dom/src/index.ts",
      "packages/compiler-core/src/index.ts",
      "packages/compiler-sfc/src/index.ts",
      "packages/router/src/index.ts",
      "packages/ld/src/index.ts",
      "packages/vite-plugin/src/index.ts",
      "packages/cli/src/index.ts",
      "packages/devtools/src/index.ts"
    ],
    "analysisPurpose": [
      "识别已存在的模块导出",
      "避免重复导出",
      "确保导入的API确实存在",
      "维护模块间的清晰依赖关系",
      "确保类型兼容性"
    ],
    "importPatterns": {
      "sameModule": "从'./index.ts'导入当前模块的其他API",
      "differentModule": "从'@ld/[module]'导入其他模块的API",
      "typesOnly": "使用import type导入类型"
    }
  },
  "generationTemplates": {
    "preGenerationTemplate": "// AI代码生成预处理模板\n// 在生成任何代码前，执行以下步骤：\n// 1. 读取并分析关键文件\nconst moduleExports = readAndAnalyzeModuleExports();\nconst targetModuleIndex = readAndAnalyzeModuleIndex(currentModule);\n// 2. 识别依赖关系\nconst dependencies = identifyDependencies(targetFile, moduleExports);\n// 3. 设计导入语句\nconst imports = designImports(dependencies, targetModuleIndex);\n// 4. 生成代码主体\nconst codeBody = generateCodeBody(targetFile, imports);\n// 5. 更新导出文件\nupdateIndexTs(targetModule, newExports);\nupdateModuleTs(targetModule, newExports);\n// 6. 生成测试\ngenerateTestFile(targetFile, testCases);\n",
    "importStatementTemplate": "// 导入语句生成规则：\n// 1. 同一模块内的导入：从'./index.ts'导入\n// 2. 其他模块的导入：从'@ld/[module]'导入\n// 3. 类型导入：使用import type\n// 示例：\nimport { createSignal, type Signal } from './index';\nimport type { Component } from '@ld/runtime-core';\n"
  }
}